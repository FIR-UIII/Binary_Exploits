MASM32 v11 download: https://masm32.com/download.htm
RadAsm IDE: http://www.assembly.com.br/
WinAsm Studio IDE: https://winasm.org/index.html
Online: https://www.tutorialspoint.com/compile_assembly_online.php 
        https://carlosrafaelgn.com.br/Asm86/
        https://yjdoc2.github.io/8086-emulator-web/compile 
        
Онлайн компилятор в ASM из вернеуровнего ЯП: https://godbolt.org/

### Общее
| Level               |  Language             | Code                  |
| --------------------| --------------------  | --------------------  |
| High-level language | C++                   | sum = 5;              |
| Asssembly           | GNU Assembler         | movl $0x5, -0x8(%ebp) |
| Machine language    | IA-32                 | C745F805000000        |
| Digital logic       | Binary                | 1100 0111 0100 0101 1111 1000 0000 0101 0000 0000 0000 0000 0000 0000 |

### Синтаксис и Типы ассемблеров ASM
Есть два синтаксиса AT&T - UNIX, Intel - MASM Windows
Для каждой архитектуры процессовров свой асм. Нет кроссплатформенность но есть обратная совместимость для семейства архитектуры



Address: 0xffff0000
Word: \xAA\xBB\xCC\xDD

| GAS \\ GCC | MASM  | NASM | ARM64 |
| --------- | ---------- | ------- | ----------- |
| .data<br>.globl greet<br>greet:<br>.string "Hello world!"<br>.text<br>.global main<br>main:<br>pushq %rbp<br>movq %rsp, %rbp| .686<br>.model small<br>.stack 100h<br>.data<br>msg db 'Hello world!$'<br>.code<br>start:<br>mov ah, 09h ; Display the message<br>lea dx, msg<br>int 21h | section .data<br>msg db "Hello world!", 0ah<br>section .text<br>global \_start<br>_start:<br>mov rax, 1  | .global \_start // устанавливаем стартовый адрес программы<br>_start: mov X0, #1 // 1 = StdOut - поток вывода<br>ldr X1, =hello // строка для вывода на экран<br>mov X2, #19 // длина строки |
| GNU Assembler или сокращенно GAS. Он поставляется как компонент набора компиляторов GCC.<br>GAS использует синтаксис, отличный от синтаксиса Intel (а именно синтаксис AT&T)<br>https://metanit.com/assembler/gas/1.4.php<br>https://www.onlinegdb.com/online_gcc_assembler<br>https://godbolt.org/<br>[https://www.jdoodle.com/compile-assembler-gcc-online](https://www.jdoodle.com/compile-assembler-gcc-online) | Преимуществом MASM является то, что MASM использует для своих инструкций синтаксис Intel. Недостатком MASM является наличие официальной поддержки только для ОС Windows. | Netwide Assembler или NASM развивается как opensource-проект и использует синтаксис, который похож на синтаксис Intel. Является кросс-платформенным и работает почти на любой платформе.<br>https://www.mycompiler.io/new/asm-x86_64<br>https://onecompiler.com/assembly/ | iOS и Android, Raspberry Pi. |

### Архитектуры
x86. Процессоры 8086 и 8088 были 16-битными, несмотря на 8-битную шину данных в 8088. Регистры в этих процессорах имели разрядность 16 бит, а набор инструкций работал с 16-битными данными. <br>

х64

х32

х16

### Создание программы
Для выполнения используются инструкции ISA. Связующее звено между железом и софтом
Компилятор > АСМ код > Ассемблер > Объектный код мнемоники
Линкер связывает объекты между собой в исполняемый файл (.exe)
Загрузчик загружает исполняемый файл в память CPU
Нет функций, циклов, ООП и проч.

# Основные понятия
1. Разрядность - размер регистров и машинного слова (16-бит реальных адресов, 32-бит защищенный режим, 86-бит long mode)

##### Регистры
ячейки памяти в ЦП для хранения данных. Несмотря на специализацию, все регистры можно использовать в любых машинных операциях. Однако надо учитывать тот факт, что некоторые команды работают только с определёнными регистрами. Например, команды умножения и деления используют регистры EAX и EDX для хранения исходных данных и результата операции. Команды управления циклом используют регистр ECX в качестве счётчика циклах. Ещё один нюанс состоит в использовании регистров в качестве базы, т.е. хранилища адреса оперативной памяти. В качестве регистров базы можно использовать любые регистры, но желательно использовать регистры EBX, ESI, EDI или EBP. В этом случае размер машинной команды обычно бывает меньше. <br>

+-----------------+---------------+---------------+------------+
| 8 Byte Register | Lower 4 Bytes | Lower 2 Bytes | Lower Byte |
+-----------------+---------------+---------------+------------+
|   rbp           |     ebp       |     bp        |     bpl    |
|   rsp           |     esp       |     sp        |     spl    |
|   rip           |     eip       |               |            |
|   rax           |     eax       |     ax        |     al     |
|   rbx           |     ebx       |     bx        |     bl     |
|   rcx           |     ecx       |     cx        |     cl     |
|   rdx           |     edx       |     dx        |     dl     |
|   rsi           |     esi       |     si        |     sil    |
|   rdi           |     edi       |     di        |     dil    |
|   r8            |     r8d       |     r8w       |     r8b    |
|   r9            |     r9d       |     r9w       |     r9b    |
|   r10           |     r10d      |     r10w      |     r10b   |
|   r11           |     r11d      |     r11w      |     r11b   |
|   r12           |     r12d      |     r12w      |     r12b   |
|   r13           |     r13d      |     r13w      |     r13b   |
|   r14           |     r14d      |     r14w      |     r14b   |
|   r15           |     r15d      |     r15w      |     r15b   |
+-----------------+---------------+---------------+------------+

Ключевые регистры<br>
ESI / SI (source index register) – индекс источника;<br>
EDI / DI (destination index register) – индекс приёмника (получателя);<br>

EIP / IP Instruction Pointer stores the offset address of the next instruction to be executed<br>
EBP / BP (stack base pointer or frame pointer) – регистр указателя на bottom конец или низ стека<br>
ESP / SP (stack pointer register) – регистр указателя на top верх или  начало стека<br>

При выборе регистра важно учитывать размер принимаемых значений!<br>
Так, CL - 8-разрядный и может принимать только 8-разрядные числа. Максимальное 8-разрядное положительное число - 255. Т.е. 256 в регистр не войдет и возникнет ошибка warning: byte data exceeds bounds [-w+number-overflow]<br>

##### Сегменты 
Отдельная область программы
Сегменты данных:
.data - преинициализированные переменные
.rodata - не инициализированные переменные для чтения
.bss  - не инициализированные переменные для записи
stack - статично назначенные переменные 
heap - динамически назначенные переменные (malloc())

4. Модель памяти. Сегменты присваиваются пространству в памяти (ОЗУ) 
  FLAT x86 - один сегмент
4. Соглашение о вызовах - 
5. Секции - разделы программы по обрабатываемых задачам

##### Операнды
dword - тип данных 
[1111] - адрес памяти
123 - целое число
"string" - строка

##### Глобальные переменные
;Можно передавать данные через глобальные переменные. Находятся в секциях .data, .rodata, .bss.
Глобальные переменные обнуляются в начале работы другой программы.
недостаток: такой способ не защищен от рекурсии. не безопасный для мультитредовой среды (когда регистр может быть использован другим потоком)
```
_DATA   SEGMENT
COMM    x:DWORD
_DATA   ENDS
```

##### Локальные переменные
Локальные переменные всегда хранятся в стеке, в отличие от глобальных переменных хранящихся в отдельных секциях кода
```
_x$ = 32
```

### Инструкции и базовые работы с данными

```
  mov   x, 0		   ; 0 может иметь любой размер, в данном случае берётся 1 байт
  mov   eax, 0		 ; 0 может иметь любой размер, в данном случае берётся 4 байта
  mov   al, 1000h  ; Ошибка – попытка записать 2-байтное число в 1-байтный регистр
  mov   eax, cx		 ; Ошибка – размеры операндов не совпадают
  mov   [ebx], 0	 ; Ошибка, т.к. 0 может иметь любой размер
  mov   byte ptr [ebx], 0 	; Пересылаем 1 байт
  mov   dword ptr [ebx], 0 	; Пересылаем 4 байта
```

### СТЭК RAM
Участок оперативной памяти ОЗУ / RAM для быстрой передачи данных + регистр-указатель SP (ESP, RSP).
Стэк формируется от большего адреса в памяти к меньшему. Принцип хранения данных - обойма магазина, наполняется обратно:
Локальные переменные хранятся в стеке. 
push (добавляет информацию в стек) при этом указатель SP уменьшается на размер переменной
pop (очищает "выталкивает" информацию из стека) и указатель SP увеличивается на размер переменной
![alt text](Media/stack.png)
Стэк в асме формируется в сегменте .data. При этом формировать мы его можем 2 способами либо отталкиваясь от SP или от BP
```
mov rdx, [rsp+0x10] ; load
mov [rsp+0x10], rdx ; store

mov rdx, [rbp-0x10] ; load
mov [rbp-0x10], rdx ; store


   0x0000054d <+0>:	    push   ebp       # <---- 1. Stores previous EBP
   0x0000054e <+1>:	    mov    ebp,esp   # <---- 2. Creates new Stack Frame
   0x00000550 <+3>:	    push   ebx
   0x00000551 <+4>:	    sub    esp,0x404 # <---- 3. Moves ESP to the top
   <...SNIP...>
   0x00000580 <+51>:	leave  # <----------------------
   0x00000581 <+52>:	ret    # <--- Leave stack frame
```
Зачем нужен стэк: "долгосрочное" хранение данных на протяжении выполнении кода. Передача аргументов между функциями

### КУЧА RAM
Участок оперативной памяти для данных большого объема. 

### ФУНКЦИИ
каждая функция имет пролог и эпилог в которым мы готовим стек, где происходит манипуляция в с SP и BP
```
main    PROC       ; начало функции f
; ===== PROLOGUE
push    ebp        ; формирует стэк (область памяти) и сохраняет значение регистра EBP 
mov     ebp, esp   ; выставляет EBP равным ESP
sub     esp, X     ;  место в стеке для хранения локальных переменных
```
Эпилог функции аннулирует выделенное место в стеке и завершает работу функции
```
mov    esp, ebp   ; восстанавливает значение EBP на старое
pop    ebp        ; освобождает стэк
ret    0          ; возвращает 0 функция всегда должна что то вернуть
main    ENDP      ; конец функции f
```

### Инструкции (подробнее)
Instructions
Now we will be covering some of the more common instructions you will see. This isn't everything you will see, but here are the more common things you will see.

mov
The move instruction just moves data from one register to another. For instance:


mov rax, rdx
This will just move the data from the rdx register to the rax register.

dereference
If you ever see brackets like [], they are meant to dereference, which deals with pointers. A pointer is a value that points to a particular memory address (it is a memory address). Dereferencing a pointer means to treat a pointer like the value it points to. For instance:


mov rax, [rdx]
Will move the value pointed to by rdx into the rax register. On the flipside:


mov [rax], rdx
Will move the value of the rdx register into whatever memory is pointed to by the rax register. The actual value of the rax register does not change.

lea
The lea instruction calculates the address of the second operand, and moves that address in the first. For instance:


lea rdi, [rbx+0x10]
This will move the address rbx+0x10 into the rdi register.

add
This just adds the two values together, and stores the sum in the first argument. For instance:


add rax, rdx
That will set rax equal to rax + rdx

sub
This value will subtract the second operand from the first one, and store the difference in the first argument. For instance:


sub rsp, 0x10
This will set the rsp register equal to rsp - 0x10

xor
This will perform the binary operation xor on the two arguments it is given, and stores the result in the first operation:


xor rdx, rax
That will set the rdx register equal to rdx ^ rax.

The and and or operations essentially do the same thing, except with the and or or binary operators.

push
The push instruction will grow the stack by either 8 bytes (for x64, 4 for x86), then push the contents of a register onto the new stack space. For instance:


push rax
This will grow the stack by 8 bytes, and the contents of the rax register will be on top of the stack.

pop
The pop instruction will pop the top 8 bytes (for x64, 4 for x86) off of the stack and into the argument. Then it will shrink the stack. For instance:


pop rax
The top 8 bytes of the stack will end up in the rax register.

jmp
The jmp instruction will jump to an instruction address. It is used to redirect code execution. For instance:


jmp 0x602010
That instruction will cause the code execution to jump to 0x602010, and execute whatever instruction is there.

call & ret
This is similar to the jmp instruction. The difference is it will push the values of rbp and rip onto the stack, then jump to whatever address it is given. This is used for calling functions. After the function is finished, a ret instruction is called which uses the pushed values of rbp and rip (saved base and instruction pointers) it can continue execution right where it left off

cmp
The cmp instruction is similar to that of the sub instruction. Except it doesn't store the result in the first argument. It checks if the result is less than zero, greater than zero, or equal to zero. Depending on the value it will set the flags accordingly.

jnz / jz
This jump if not zero and jump if zero (jnz/jz) instructions are pretty similar to the jump instruction. The difference is they will only execute the jump depending on the status of the zero flag. For jz it will only jump if the zero flag is set. The opposite is true for jnz.